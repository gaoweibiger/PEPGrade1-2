<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³åŠŸèƒ½è°ƒè¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
        }
        .test-button {
            background: #3b82f6;
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #2563eb;
        }
        .test-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        .log {
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .status.success { background: #065f46; border: 1px solid #10b981; }
        .status.error { background: #7f1d1d; border: 1px solid #ef4444; }
        .status.warning { background: #78350f; border: 1px solid #f59e0b; }
        .status.info { background: #1e3a8a; border: 1px solid #3b82f6; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ è¯­éŸ³åŠŸèƒ½è°ƒè¯•å·¥å…·</h1>
        
        <div class="status info">
            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong>
            <ol>
                <li>é¦–å…ˆç‚¹å‡»"æ¿€æ´»ç”¨æˆ·äº¤äº’"</li>
                <li>ç„¶åæµ‹è¯•å„ç§è¯­éŸ³åŠŸèƒ½</li>
                <li>æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—äº†è§£è¯¦ç»†ä¿¡æ¯</li>
            </ol>
        </div>

        <div>
            <h3>ğŸ¯ åŸºç¡€æµ‹è¯•</h3>
            <button class="test-button" onclick="activateInteraction()">æ¿€æ´»ç”¨æˆ·äº¤äº’</button>
            <button class="test-button" onclick="testBasicSpeech()">åŸºç¡€è¯­éŸ³æµ‹è¯•</button>
            <button class="test-button" onclick="testEnvironment()">ç¯å¢ƒæ£€æµ‹</button>
            <button class="test-button" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        </div>

        <div>
            <h3>ğŸš€ æ€§èƒ½æµ‹è¯•</h3>
            <button class="test-button" onclick="testWarmup()">é¢„çƒ­æµ‹è¯•</button>
            <button class="test-button" onclick="testResponseTime()">å“åº”æ—¶é—´æµ‹è¯•</button>
            <button class="test-button" onclick="testMultiple()">è¿ç»­æ’­æ”¾æµ‹è¯•</button>
        </div>

        <div>
            <h3>ğŸ› ï¸ æ•…éšœæ’é™¤</h3>
            <button class="test-button" onclick="testSynthesisFailed()">æ¨¡æ‹Ÿ synthesis-failed</button>
            <button class="test-button" onclick="resetEngine()">é‡ç½®è¯­éŸ³å¼•æ“</button>
            <button class="test-button" onclick="showVoices()">æ˜¾ç¤ºå¯ç”¨è¯­éŸ³</button>
        </div>

        <div id="status-display"></div>
        <div class="log" id="log-output"></div>
    </div>

    <script>
        // ç®€åŒ–çš„æ—¥å¿—ç³»ç»Ÿ
        const logOutput = document.getElementById('log-output');
        const statusDisplay = document.getElementById('status-display');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            const div = document.createElement('div');
            div.textContent = logEntry;
            div.style.color = type === 'error' ? '#ef4444' : 
                             type === 'success' ? '#10b981' : 
                             type === 'warning' ? '#f59e0b' : '#94a3b8';
            
            logOutput.appendChild(div);
            logOutput.scrollTop = logOutput.scrollHeight;
            
            console.log(logEntry);
        }

        function showStatus(message, type = 'info') {
            statusDisplay.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function clearLog() {
            logOutput.innerHTML = '';
            statusDisplay.innerHTML = '';
        }

        // æ£€æŸ¥åŸºç¡€æ”¯æŒ
        const speechSupported = 'speechSynthesis' in window;
        const isWeChat = /MicroMessenger/i.test(navigator.userAgent);
        let userInteracted = false;

        log(`æµè§ˆå™¨æ”¯æŒè¯­éŸ³åˆæˆ: ${speechSupported}`);
        log(`å¾®ä¿¡æµè§ˆå™¨: ${isWeChat}`);
        log(`ç”¨æˆ·ä»£ç†: ${navigator.userAgent}`);

        // æ¿€æ´»ç”¨æˆ·äº¤äº’
        function activateInteraction() {
            userInteracted = true;
            log('ç”¨æˆ·äº¤äº’å·²æ¿€æ´»', 'success');
            showStatus('âœ… ç”¨æˆ·äº¤äº’å·²æ¿€æ´»', 'success');
            
            // å°è¯•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (isWeChat) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                        log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤', 'success');
                    }
                } catch (error) {
                    log(`éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                }
            }
        }

        // åŸºç¡€è¯­éŸ³æµ‹è¯•
        async function testBasicSpeech() {
            if (!speechSupported) {
                showStatus('âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ', 'error');
                return;
            }

            if (isWeChat && !userInteracted) {
                showStatus('âš ï¸ è¯·å…ˆæ¿€æ´»ç”¨æˆ·äº¤äº’', 'warning');
                return;
            }

            log('å¼€å§‹åŸºç¡€è¯­éŸ³æµ‹è¯•...');
            showStatus('ğŸµ æ­£åœ¨æµ‹è¯•è¯­éŸ³æ’­æ”¾...', 'info');

            try {
                const utterance = new SpeechSynthesisUtterance('Hello, this is a test!');
                utterance.lang = 'en-US';
                utterance.rate = isWeChat ? 0.7 : 0.8;
                utterance.volume = 1;

                let started = false;
                let ended = false;

                const timeout = setTimeout(() => {
                    if (!started) {
                        log('è¯­éŸ³æ’­æ”¾å¯åŠ¨è¶…æ—¶', 'error');
                        showStatus('âŒ è¯­éŸ³æ’­æ”¾å¯åŠ¨è¶…æ—¶', 'error');
                    }
                }, 3000);

                utterance.onstart = () => {
                    started = true;
                    clearTimeout(timeout);
                    log('è¯­éŸ³æ’­æ”¾å¼€å§‹', 'success');
                };

                utterance.onend = () => {
                    ended = true;
                    log('è¯­éŸ³æ’­æ”¾å®Œæˆ', 'success');
                    showStatus('âœ… è¯­éŸ³æ’­æ”¾æˆåŠŸ', 'success');
                };

                utterance.onerror = (event) => {
                    clearTimeout(timeout);
                    log(`è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`, 'error');
                    showStatus(`âŒ è¯­éŸ³æ’­æ”¾é”™è¯¯: ${event.error}`, 'error');
                };

                speechSynthesis.cancel();
                speechSynthesis.speak(utterance);

            } catch (error) {
                log(`è¯­éŸ³æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                showStatus(`âŒ è¯­éŸ³æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        // ç¯å¢ƒæ£€æµ‹
        function testEnvironment() {
            log('=== ç¯å¢ƒæ£€æµ‹å¼€å§‹ ===');
            
            // åŸºç¡€ä¿¡æ¯
            log(`æµè§ˆå™¨: ${navigator.userAgent}`);
            log(`è¯­éŸ³åˆæˆæ”¯æŒ: ${speechSupported}`);
            log(`ç”¨æˆ·äº¤äº’çŠ¶æ€: ${userInteracted}`);
            
            if (speechSupported) {
                // è¯­éŸ³åˆ—è¡¨
                const voices = speechSynthesis.getVoices();
                log(`å¯ç”¨è¯­éŸ³æ•°é‡: ${voices.length}`);
                
                if (voices.length > 0) {
                    const englishVoices = voices.filter(v => v.lang.startsWith('en-'));
                    log(`è‹±è¯­è¯­éŸ³æ•°é‡: ${englishVoices.length}`);
                    
                    if (englishVoices.length > 0) {
                        log(`æ¨èè¯­éŸ³: ${englishVoices[0].name} (${englishVoices[0].lang})`);
                    }
                } else {
                    log('è¯­éŸ³åˆ—è¡¨ä¸ºç©ºï¼Œå¯èƒ½éœ€è¦ç­‰å¾…åŠ è½½', 'warning');
                }
                
                // è¯­éŸ³åˆæˆå™¨çŠ¶æ€
                log(`è¯­éŸ³åˆæˆå™¨çŠ¶æ€: ${speechSynthesis.speaking ? 'æ’­æ”¾ä¸­' : 'ç©ºé—²'}`);
                log(`è¯­éŸ³åˆæˆå™¨æš‚åœ: ${speechSynthesis.paused}`);
                log(`è¯­éŸ³åˆæˆå™¨å¾…æ’­æ”¾: ${speechSynthesis.pending}`);
            }
            
            // å¾®ä¿¡ç‰¹æ®Šæ£€æµ‹
            if (isWeChat) {
                const versionMatch = navigator.userAgent.match(/MicroMessenger\/(\d+)\.(\d+)\.(\d+)/);
                if (versionMatch) {
                    const version = `${versionMatch[1]}.${versionMatch[2]}.${versionMatch[3]}`;
                    log(`å¾®ä¿¡ç‰ˆæœ¬: ${version}`);
                    
                    const majorVersion = parseInt(versionMatch[1]);
                    log(`ç‰ˆæœ¬æ”¯æŒçŠ¶æ€: ${majorVersion >= 7 ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
                }
                
                log(`å°ç¨‹åºç¯å¢ƒ: ${window.__wxjs_environment === 'miniprogram' ? 'æ˜¯' : 'å¦'}`);
            }
            
            log('=== ç¯å¢ƒæ£€æµ‹å®Œæˆ ===');
            showStatus('âœ… ç¯å¢ƒæ£€æµ‹å®Œæˆï¼Œè¯·æŸ¥çœ‹æ—¥å¿—', 'success');
        }

        // é¢„çƒ­æµ‹è¯•
        async function testWarmup() {
            log('å¼€å§‹é¢„çƒ­æµ‹è¯•...');
            const startTime = performance.now();
            
            try {
                // æ¨¡æ‹Ÿé¢„çƒ­è¿‡ç¨‹
                const voices = speechSynthesis.getVoices();
                log(`åŠ è½½è¯­éŸ³åˆ—è¡¨: ${voices.length} ä¸ª`);
                
                // é™éŸ³æµ‹è¯•æ’­æ”¾
                const testUtterance = new SpeechSynthesisUtterance(' ');
                testUtterance.volume = 0;
                testUtterance.rate = 1;
                
                await new Promise((resolve) => {
                    const timeout = setTimeout(resolve, 500);
                    
                    testUtterance.onstart = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    testUtterance.onend = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    testUtterance.onerror = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    speechSynthesis.speak(testUtterance);
                });
                
                const endTime = performance.now();
                const warmupTime = Math.round(endTime - startTime);
                
                log(`é¢„çƒ­å®Œæˆï¼Œè€—æ—¶: ${warmupTime}ms`, 'success');
                showStatus(`âœ… é¢„çƒ­å®Œæˆï¼Œè€—æ—¶: ${warmupTime}ms`, 'success');
                
            } catch (error) {
                log(`é¢„çƒ­å¤±è´¥: ${error.message}`, 'error');
                showStatus(`âŒ é¢„çƒ­å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å“åº”æ—¶é—´æµ‹è¯•
        async function testResponseTime() {
            log('å¼€å§‹å“åº”æ—¶é—´æµ‹è¯•...');
            
            const startTime = performance.now();
            
            try {
                const utterance = new SpeechSynthesisUtterance('Speed test');
                utterance.volume = 0.1;
                utterance.rate = 2.0;
                
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('å“åº”è¶…æ—¶'));
                    }, 3000);
                    
                    utterance.onstart = () => {
                        const endTime = performance.now();
                        const responseTime = Math.round(endTime - startTime);
                        clearTimeout(timeout);
                        log(`å“åº”æ—¶é—´: ${responseTime}ms`, 'success');
                        showStatus(`âœ… å“åº”æ—¶é—´: ${responseTime}ms`, 'success');
                        resolve();
                    };
                    
                    utterance.onerror = (event) => {
                        clearTimeout(timeout);
                        reject(new Error(`æ’­æ”¾é”™è¯¯: ${event.error}`));
                    };
                    
                    speechSynthesis.cancel();
                    speechSynthesis.speak(utterance);
                });
                
            } catch (error) {
                log(`å“åº”æ—¶é—´æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                showStatus(`âŒ å“åº”æ—¶é—´æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // è¿ç»­æ’­æ”¾æµ‹è¯•
        async function testMultiple() {
            log('å¼€å§‹è¿ç»­æ’­æ”¾æµ‹è¯•...');
            const words = ['One', 'Two', 'Three'];
            let successCount = 0;
            
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                log(`æ’­æ”¾ç¬¬ ${i + 1} ä¸ª: ${word}`);
                
                try {
                    const utterance = new SpeechSynthesisUtterance(word);
                    utterance.volume = 0.1;
                    utterance.rate = 2.0;
                    
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('è¶…æ—¶'));
                        }, 2000);
                        
                        utterance.onend = () => {
                            clearTimeout(timeout);
                            successCount++;
                            resolve();
                        };
                        
                        utterance.onerror = () => {
                            clearTimeout(timeout);
                            resolve(); // ç»§ç»­ä¸‹ä¸€ä¸ª
                        };
                        
                        speechSynthesis.speak(utterance);
                    });
                    
                    // çŸ­æš‚é—´éš”
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    log(`æ’­æ”¾ ${word} å¤±è´¥: ${error.message}`, 'warning');
                }
            }
            
            const successRate = (successCount / words.length) * 100;
            log(`è¿ç»­æ’­æ”¾å®Œæˆï¼ŒæˆåŠŸç‡: ${successRate.toFixed(1)}%`, 'success');
            showStatus(`âœ… è¿ç»­æ’­æ”¾å®Œæˆï¼ŒæˆåŠŸç‡: ${successRate.toFixed(1)}%`, 'success');
        }

        // é‡ç½®å¼•æ“
        async function resetEngine() {
            log('é‡ç½®è¯­éŸ³å¼•æ“...');
            
            try {
                speechSynthesis.cancel();
                
                await new Promise(resolve => {
                    setTimeout(() => {
                        const voices = speechSynthesis.getVoices();
                        log(`å¼•æ“é‡ç½®å®Œæˆï¼Œå¯ç”¨è¯­éŸ³: ${voices.length}`, 'success');
                        resolve();
                    }, 300);
                });
                
                showStatus('âœ… è¯­éŸ³å¼•æ“é‡ç½®å®Œæˆ', 'success');
                
            } catch (error) {
                log(`å¼•æ“é‡ç½®å¤±è´¥: ${error.message}`, 'error');
                showStatus(`âŒ å¼•æ“é‡ç½®å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºå¯ç”¨è¯­éŸ³
        function showVoices() {
            const voices = speechSynthesis.getVoices();
            log('=== å¯ç”¨è¯­éŸ³åˆ—è¡¨ ===');
            
            if (voices.length === 0) {
                log('æ²¡æœ‰å¯ç”¨è¯­éŸ³', 'warning');
            } else {
                voices.forEach((voice, index) => {
                    log(`${index + 1}. ${voice.name} (${voice.lang}) - ${voice.localService ? 'æœ¬åœ°' : 'åœ¨çº¿'}`);
                });
            }
            
            log('=== è¯­éŸ³åˆ—è¡¨ç»“æŸ ===');
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            log('é¡µé¢åŠ è½½å®Œæˆ');
            
            // ç›‘å¬è¯­éŸ³åˆ—è¡¨å˜åŒ–
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => {
                    const voices = speechSynthesis.getVoices();
                    log(`è¯­éŸ³åˆ—è¡¨æ›´æ–°: ${voices.length} ä¸ªè¯­éŸ³å¯ç”¨`);
                };
            }
            
            // è‡ªåŠ¨æ£€æµ‹ç¯å¢ƒ
            setTimeout(() => {
                testEnvironment();
            }, 1000);
        });

        // è‡ªåŠ¨æ¿€æ´»ç”¨æˆ·äº¤äº’
        document.addEventListener('click', () => {
            if (!userInteracted) {
                activateInteraction();
            }
        }, { once: true });
    </script>
</body>
</html>
